# Участие в разработке

Спасибо за ваш интерес к развитию ALT Booster! Этот документ поможет вам понять архитектуру приложения и стандарты кода, принятые в проекте.

## Философия и архитектура

ALT Booster — это не просто набор скриптов, а полноценное десктоп-приложение с продуманной архитектурой. Ключевые принципы:

1.  **Безопасность и надёжность:** Все операции, особенно требующие прав `sudo`, спроектированы так, чтобы быть максимально безопасными. Мы избегаем прямых вызовов системных команд в пользу обёрток из `src/system/privileges.py`, которые используют безопасный механизм `SUDO_ASKPASS`. Перед выполнением деструктивных действий (например, удаление пакетов) выполняются проверки зависимостей.

2.  **Отзывчивый интерфейс:** Ни одна операция не должна "замораживать" приложение. Все длительные задачи (сетевые запросы, установка пакетов, системные проверки) выполняются в отдельных потоках (`threading.Thread`), а результаты безопасно передаются в основной поток GTK через `GLib.idle_add`.

3.  **Разделение логики:** Код чётко разделён на:
    - **Frontend (`src/ui/`):** Визуальная часть, отвечающая только за отображение и пользовательский ввод.
    - **Backend (`src/system/`):** Системная логика, выполнение команд и проверки.
    - **Фасад (`src/backend.py`):** Единая точка входа для UI, которая скрывает сложную структуру бэкенда.

4.  **Data-Driven UI:** Значительная часть интерфейса (вкладки "Обслуживание", "AMD", "Терминал") и каталоги (список приложений) не закодированы жёстко, а генерируются "на лету" из JSON-файлов в `src/modules/`. Это позволяет легко добавлять новые твики и приложения, не трогая основной код на Python.

## Структура проекта

```
altbooster/
├── icons/                 # Графические ресурсы (иконки .svg, .png)
├── src/                   # Исходный код приложения
│   ├── builtin_actions/   # Функции-обработчики для действий из динамических вкладок
│   ├── modules/           # JSON-файлы, описывающие UI для динамических страниц и задач
│   ├── system/            # Бэкенд-модули для взаимодействия с системой
│   │   ├── checks.py      # Функции для проверки состояния системы (установлен ли пакет и т.д.)
│   │   ├── gsettings.py   # Обертка для работы с GSettings
│   │   ├── packages.py    # Зарезервировано для будущего функционала по работе с пакетами
│   │   ├── privileges.py  # Модуль для безопасного выполнения команд с sudo
│   │   └── tweaks.py      # Реализация конкретных системных твиков
│   ├── ui/                # Модули, отвечающие за отрисовку UI
│   │   ├── dialogs.py     # Кастомные диалоговые окна (ввод пароля, редактор)
│   │   ├── rows.py        # Библиотека переиспользуемых виджетов (TaskRow, AppRow, SettingRow)
│   │   └── *.py           # Файлы, описывающие каждую статическую вкладку
│   ├── backend.py         # Фасад, предоставляющий единый и чистый API для всего бэкенда
│   ├── config.py          # Управление конфигурацией, путями и состоянием сессии
│   ├── dynamic_page.py    # Движок, генерирующий UI на основе JSON-конфигураций
│   ├── main.py            # Точка входа в приложение
│   └── widgets.py         # Простые фабрики для создания стандартных виджетов Adwaita/GTK
├── install.sh             # Скрипт установки
├── uninstall.sh           # Скрипт удаления
└── pyproject.toml         # Метаданные проекта и зависимости (PEP 621)
```

## Как внести свой вклад

### 1. Добавление приложения в каталог

Каталог приложений находится в `src/modules/apps.json`. Чтобы добавить новое приложение, найдите подходящую группу (например, `"id": "browsers"`) и добавьте новый объект в массив `items`.

**Структура объекта приложения:**
- `id`: Уникальный идентификатор (латиница, `snake_case`).
- `label`: Человекочитаемое название.
- `desc`: Краткое описание.
- `sources`: **Список** источников установки. Приложение может иметь несколько способов установки (например, Flatpak и EPM).

**Структура источника (`source`):**
- `label`: Текст для бейджа в UI (например, "Flathub", "EPM").
- `cmd`: Команда для установки в виде списка аргументов.
- `check`: Команда для проверки, установлено ли приложение. Состоит из типа проверки и значения.

**Примеры:**
```json
// Пример для Flatpak
{
  "id": "telegram",
  "label": "Telegram Desktop",
  "desc": "Официальный клиент Telegram",
  "sources": [
    {
      "label": "Flathub",
      "cmd": ["flatpak", "install", "-y", "flathub", "org.telegram.desktop"],
      "check": ["flatpak", "org.telegram.desktop"]
    }
  ]
}

// Пример для EPM (RPM-пакет)
{
  "id": "gimp",
  "label": "GIMP",
  "desc": "Графический редактор",
  "sources": [
    {
      "label": "EPM",
      "cmd": ["epm", "-i", "-y", "gimp"],
      "check": ["rpm", "gimp"]
    }
  ]
}
```

### 2. Добавление задачи обслуживания

Задачи обслуживания находятся в `src/modules/maintenance.json`. Просто добавьте новый объект в массив `tasks`.

**Структура объекта задачи:**
- `id`: Уникальный идентификатор.
- `icon`: Имя иконки Adwaita (например, `utilities-terminal-symbolic`).
- `label`: Название задачи.
- `desc`: Краткое описание.
- `cmd`: Команда для выполнения. По умолчанию выполняется через `sudo`.
- `type` (опционально): Если указать `"user"`, команда будет выполнена от имени текущего пользователя без `sudo`.
- `check` (опционально): Объект для проверки, выполнена ли задача. Если проверка проходит, кнопка будет неактивна.

**Пример:**
```json
{
  "id": "clear_temp",
  "icon": "user-trash-symbolic",
  "label": "Очистить /tmp",
  "desc": "Удаляет временные файлы из /tmp",
  "cmd": ["rm", "-rf", "/tmp/*"],
  "check": {
    "type": "path_empty", // вымышленный тип, для примера
    "value": "/tmp"
  }
}
```

### 3. Стиль кода и проверка

Проект использует `ruff` для форматирования и линтинга. Перед коммитом, пожалуйста, выполните проверку:

```bash
# Установка (если не установлен)
pip install ruff

# Проверка кода
ruff check src/
```

- Максимальная длина строки — 100 символов.
- Используйте `Type hints` для всех публичных функций.
- Пишите `docstring` для классов и нетривиальных функций.
- `bare except` (`except:`) запрещён — всегда указывайте тип исключения (`except OSError:`).

### 4. Процесс отправки Pull Request

1.  Сделайте форк репозитория.
2.  Создайте новую ветку для вашей фичи: `git checkout -b feat/my-awesome-feature`.
3.  Внесите изменения и проверьте код с помощью `ruff`.
4.  Отправьте Pull Request, подробно описав, **что** и **зачем** вы изменили.

Спасибо за ваш вклад в улучшение ALT Booster!
